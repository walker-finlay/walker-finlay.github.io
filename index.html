<!DOCTYPE html>
<html lang="en"> 
	<head>
		<meta charset="utf-8">
		<title>My first three.js app</title>
		<style>
			body { margin: 0; }
		</style>
	</head>
	<body>
		<script src="js/three.js"></script>
        <script src="js/controls/OrbitControls.js"></script>
		<script>
            // Setup ==========================================================
            const width = window.innerWidth; /* For (marginal) speed */
            const height = window.innerHeight;

			const scene = new THREE.Scene();
            scene.background = new THREE.Color(0xffffff)
            const camera = new THREE.PerspectiveCamera(75, width / height, 0.1, 1000);
            const renderer = new THREE.WebGLRenderer(
                {antialias: true}
            );
            renderer.setPixelRatio( window.devicePixelRatio );
            renderer.setSize(width, height);
            document.body.appendChild(renderer.domElement);

            // const axesHelper = new THREE.AxesHelper( 5 );
            // scene.add( axesHelper ); // FIXME: debugging purposes only 

            // Controls =======================================================
            const controls = new THREE.OrbitControls(camera, renderer.domElement);

            // Link stuff =====================================================
            const raycaster = new THREE.Raycaster();
            const pointer = new THREE.Vector2();
            const onClickPosition = new THREE.Vector2();

            let INTERSECTED;

            const ghGeometry = new THREE.BoxGeometry(0.9,0.1,0.1);
            const ghMaterial = new THREE.LineBasicMaterial({
                color: 0x00ff00,
                linewidth: 1,
                linecap: 'round',
                linejoin: 'round',
                opacity: 0.5,
                transparent: true,
            });
            const gh = new THREE.Mesh(ghGeometry, ghMaterial);
            gh.position.set(0,-0.7,0);
            scene.add(gh);
            

            // const liGeometry = new THREE.BoxGeometry(1,0.1,0.1);
            // const liWireframe = new THREE.WireframeGeometry(liGeometry);
            // const liLine = new THREE.LineSegments(liWireframe);
            // liLine.position.set(0.95,-0.7,0);
            // scene.add(liLine);

            // Card ===========================================================
            const loader = new THREE.TextureLoader();
            const geometry = new THREE.BoxGeometry(3.5, 2, 0.02);
            const paper = loader.load("images/embossed.jpg");
            const ink = loader.load("images/ink.jpg");
            const material = new THREE.MeshStandardMaterial({
                color: 0xf7f0d5,
                normalMap: paper,
                map: ink
            });

            const cube = new THREE.Mesh(geometry, material);
            scene.add(cube);
            camera.position.z = 2;
            // camera.position.set(-1,1,2);
            camera.lookAt(scene.position);

            // Light ==========================================================
            const light = new THREE.HemisphereLight(0xffffbb, 0x080820, 0.5);
            scene.add(light);

            // const directionalLight = new THREE.DirectionalLight(0xffffff, 0.5);
            // directionalLight.position.set(-1, 0, 1).normalize();
            // scene.add(directionalLight);


            const pointLight = new THREE.PointLight( 0xffffff, 1, 100 );
            scene.add( pointLight );

            // Methods ========================================================
			function onPointerMove( event ) {
                pointer.x = ( event.clientX / window.innerWidth ) * 2 - 1;
                pointer.y = - ( event.clientY / window.innerHeight ) * 2 + 1;
            }

            function animate() {
                requestAnimationFrame(animate);
                render();
            }

            function render() {
                const lightPosition = new THREE.Vector3(-1, 5, 5); /* position in camera coords */
                pointLight.position.copy(lightPosition.applyMatrix4(camera.matrixWorld));

                // find intersections
				raycaster.setFromCamera( pointer, camera );
                const intersects = raycaster.intersectObjects( scene.children );

                if (intersects.length > 0) {
                    if (INTERSECTED != intersects[0].object) {
                        if (INTERSECTED) {
                            INTERSECTED.material.color.setHex(INTERSECTED.currentHex);
                        }
                        INTERSECTED = intersects[0].object;
                        INTERSECTED.currentHex = INTERSECTED.material.color.getHex();
                        INTERSECTED.material.color.setHex(0xff0000);
                    } 
                }else {
                    if (INTERSECTED) INTERSECTED.material.color.setHex(INTERSECTED.currentHex);
                    INTERSECTED = null;
                }

                renderer.render(scene, camera);
            }

            function onWindowResize() {
                camera.aspect = window.innerWidth / window.innerHeight;
                camera.updateProjectionMatrix();
                renderer.setSize( window.innerWidth, window.innerHeight );
            }
            window.addEventListener( 'resize', onWindowResize );
            document.addEventListener( 'mousemove', onPointerMove );

            // Render loop ====================================================
            animate();
		</script>
	</body>
</html>