<!DOCTYPE html>
<html lang="en"> 
	<head>
		<meta charset="utf-8">
		<title>My first three.js app</title>
		<style>
			body { margin: 0; }
            #debug { position: absolute }
		</style>
	</head>
	<body>
        <div id='debug'>
            sum
        </div>
		<script src="js/three.js"></script>
        <script src="js/controls/OrbitControls.js"></script>
		<script>
            // Setup ==========================================================
            const width = window.innerWidth; /* For (marginal) speed */
            const height = window.innerHeight;

			const scene = new THREE.Scene();
            scene.background = new THREE.Color(0xffffff)
            const camera = new THREE.PerspectiveCamera(75, width / height, 0.1, 1000);
            const renderer = new THREE.WebGLRenderer(
                {antialias: true}
            );
            renderer.setPixelRatio( window.devicePixelRatio );
            renderer.setSize(width, height);
            document.body.appendChild(renderer.domElement);

            // const axesHelper = new THREE.AxesHelper( 5 );
            // scene.add( axesHelper ); // FIXME: debugging purposes only 
            const debug = document.getElementById('debug');

            // Controls =======================================================
            const controls = new THREE.OrbitControls(camera, renderer.domElement);

            // Link stuff =====================================================
            const raycaster = new THREE.Raycaster();
            const pointer = new THREE.Vector2();
            const mouse = new THREE.Vector2();

            let INTERSECTED, intersects;

            // Link boxes
            const ghGeometry = new THREE.BoxGeometry(0.9,0.1,0.05);
            const ghMaterial = new THREE.LineBasicMaterial({
                color: 0x00ff00,
                opacity: 0,
                transparent: true,
            });
            const gh = new THREE.Mesh(ghGeometry, ghMaterial);
            gh.name = 'gh';
            gh.userData = { URL: 'https://github.com/walker-finlay' };
            gh.clickable = true;
            gh.position.set(0,-0.7,0.03);
            scene.add(gh);

            const liGeometry = new THREE.BoxGeometry(1,0.1,0.05);
            const liMaterial = new THREE.LineBasicMaterial({
                color: 0x000000,
                opacity: 0,
                transparent: true,
            });
            const li = new THREE.Mesh(liGeometry, liMaterial);
            li.name = 'li';
            li.userData = { URL: 'https://www.linkedin.com/in/walker-finlay2/' };
            li.clickable = true;
            li.position.set(1,-0.7,0.03);
            scene.add(li);

            // Texture maps ===================================================
            // Ink and paper
            const loader = new THREE.TextureLoader(); // TODO: Get a cube texture loader
            const geometry = new THREE.BoxGeometry(3.5, 2, 0.02);
            const paper = loader.load("images/embossed.jpg");
            const ink = loader.load("images/ink.jpg");
            const material = new THREE.MeshStandardMaterial({
                color: 0xf7f0d5,
                normalMap: paper,
                map: ink
            });

            const cube = new THREE.Mesh(geometry, material);
            cube.name = 'card';
            scene.add(cube);
            camera.position.z = 2;
            camera.lookAt(scene.position);

            // Light ==========================================================
            const light = new THREE.HemisphereLight(0xffffbb, 0x080820, 0.5);
            scene.add(light);


            const pointLight = new THREE.PointLight( 0xffffff, 1, 100 );
            scene.add( pointLight );

            // Methods ========================================================
			function onPointerMove( event ) { /* px to ndc */
                pointer.x = ( event.clientX / window.innerWidth ) * 2 - 1;
                pointer.y = - ( event.clientY / window.innerHeight ) * 2 + 1;
                mouse.x = event.clientX;
                mouse.y = event.clientY;
                debug.innerHTML = `${mouse.x}, ${mouse.y}`;
            }

            function animate() {
                requestAnimationFrame(animate);
                render();
            }

            function render() {
                const lightPosition = new THREE.Vector3(-1, 5, 5); /* position in camera coords */
                pointLight.position.copy(lightPosition.applyMatrix4(camera.matrixWorld));

                // find intersections
				raycaster.setFromCamera( pointer, camera );
                intersects = raycaster.intersectObjects( scene.children );

                if (intersects.length > 0) { /* one or more intersections */
                    if (intersects[0].object.clickable) {
                        document.body.style.cursor = 'pointer';
                    } else {
                        document.body.style.cursor = 'default';
                    }
                    // if (INTERSECTED != intersects[0].object) { /* new one */
                    //     if (INTERSECTED) { /* reset old one */
                    //         INTERSECTED.material.color.setHex(INTERSECTED.currentHex);
                    //     }
                    //     INTERSECTED = intersects[0].object;
                    //     INTERSECTED.currentHex = INTERSECTED.material.color.getHex();
                    //     INTERSECTED.material.color.setHex(0xff0000);
                    // } 
                } else { /* no intersection */
                    document.body.style.cursor = 'default';
                    // if (INTERSECTED) {
                    //     INTERSECTED.material.color.setHex(INTERSECTED.currentHex);
                    // }
                    // INTERSECTED = null;
                }

                renderer.render(scene, camera);
            }

            function onLinkClick(e) {
                if (intersects.length > 0 && intersects[0].object.clickable) {
                    window.open(intersects[0].object.userData.URL);
                }
            }

            function onWindowResize() {
                camera.aspect = window.innerWidth / window.innerHeight;
                camera.updateProjectionMatrix();
                renderer.setSize( window.innerWidth, window.innerHeight );
            }
            window.addEventListener( 'resize', onWindowResize );
            document.addEventListener( 'mousemove', onPointerMove );
            document.addEventListener( 'click', onLinkClick);

            // Render loop ====================================================
            animate();
		</script>
	</body>
</html>