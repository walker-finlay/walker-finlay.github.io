<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="utf-8">
    <title>walker-finlay.github.io</title>
    <style>
        body {
            margin: 0;
        }

        #debug {
            position: absolute;
            user-select: none;
        }

        .logo {
            height: 0px;
            width: auto;
            position: absolute;
            transition: transform 0.25s;
            transform-origin: center;
        }

        .logo.shown {
            height: 1px;
            width: auto;
            transform-origin: center;
            transform: rotate(359deg) scale(50);
        }

        .message-container {
            position: absolute;
            top: 20px;
            left: 20px;
        }

        .message-container.shown {
            border: 2px solid white;
            border-radius: 15px;
        }

        .message {
            transition: 0.5s;
            position: absolute;
            left: -100px;
            color: white;
            margin-left: 15px;
            margin-right: 15px;
        }

        .message.shown {
            transition: 0.5s;
            left: 0px;
        }
    </style>
</head>

<body>
    <div id="msg-box" class="message-container">
        <p id="msg" class="message">Welcome</p>
    </div>
    <img id='gh-logo' class='logo' src="images/sprites/GitHub-Mark-120px-plus.png">
    <img id='li-logo' class='logo' src='images/sprites/LI-In-Bug.png'>
    <script src="js/three.js"></script>
    <script src="js/controls/OrbitControls.js"></script>
    <script src="js/loaders/GLTFLoader.js"></script>
    <script>
        // Setup ==========================================================
        const width = window.innerWidth; /* For (marginal) speed */
        const height = window.innerHeight;

        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x2b2b2b)
        const camera = new THREE.PerspectiveCamera(75, width / height, 0.1, 1000);
        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setPixelRatio(window.devicePixelRatio);
        renderer.setSize(width, height);
        document.body.appendChild(renderer.domElement);

        const size = 20;
        const divisions = 20;

        const gridHelper = new THREE.GridHelper(size, divisions);
        gridHelper.position.set(0, -1, 0);
        scene.add(gridHelper);

        // Controls =======================================================
        const controls = new THREE.OrbitControls(camera, renderer.domElement);
        controls.minDistance = 0.6;

        // Link stuff =====================================================
        const raycaster = new THREE.Raycaster();
        const pointer = new THREE.Vector2();
        const mouse = new THREE.Vector2();

        let INTERSECTED, intersects;

        // Logos
        const ghLogo = document.getElementById('gh-logo');
        const liLogo = document.getElementById('li-logo');
        const msgBox = document.getElementById('msg-box');
        const msg = document.getElementById('msg');

        // Link boxes
        const ghGeometry = new THREE.BoxGeometry(0.9, 0.1, 0.05);
        const ghMaterial = new THREE.LineBasicMaterial({
            color: 0x00ff00,
            opacity: 0,
            transparent: true,
        });
        const gh = new THREE.Mesh(ghGeometry, ghMaterial);
        gh.name = 'gh';
        gh.userData = {
            URL: 'https://github.com/walker-finlay',
            image: ghLogo
        };
        gh.clickable = true;
        gh.position.set(0, -0.7, 0.03);
        scene.add(gh);

        const liGeometry = new THREE.BoxGeometry(1, 0.1, 0.05);
        const liMaterial = new THREE.LineBasicMaterial({
            color: 0x000000,
            opacity: 0,
            transparent: true,
        });
        const li = new THREE.Mesh(liGeometry, liMaterial);
        li.name = 'li';
        li.userData = {
            URL: 'https://www.linkedin.com/in/walker-finlay/',
            image: liLogo
        };
        li.clickable = true;
        li.position.set(1, -0.7, 0.03);
        scene.add(li);

        // Texture maps ===================================================
        // Ink and paper
        const loader = new THREE.TextureLoader(); // TODO: Get a cube texture loader
        const geometry = new THREE.BoxGeometry(3.5, 2, 0.02);
        const paper = loader.load("images/embossed.jpg");
        const ink = loader.load("images/ink.jpg");
        const material = new THREE.MeshStandardMaterial({
            color: 0xf7f0d5,
            normalMap: paper,
            map: ink
        });

        const cube = new THREE.Mesh(geometry, material);
        cube.name = 'card';
        scene.add(cube);
        camera.position.z = 2;
        camera.lookAt(scene.position);

        // Light ==========================================================
        const light = new THREE.HemisphereLight(0xffffbb, 0x080820, 0.5);
        scene.add(light);


        const pointLight = new THREE.PointLight(0xffffff, 1, 100);
        scene.add(pointLight);

        // Easter egg
        let ee;
        const modelLoader = new THREE.GLTFLoader();
        modelLoader.load('models/tall_potted_house_plant/scene.gltf', gltf => {
            ee = gltf.scene;
            ee.scale.set(0.5, 0.5, 0.5);
            ee.position.set(1.5, -1, 0.4);
            ee.visible = false;
            scene.add(ee);
        }, undefined, console.error);

        // Methods ========================================================
        function animate() {
            requestAnimationFrame(animate);
            render();
        }

        function render() {
            const lightPosition = new THREE.Vector3(-1, 5, 5); /* position in camera coords */
            pointLight.position.copy(lightPosition.applyMatrix4(camera.matrixWorld));

            // move the logo sprites to their links, regardless of camera location
            ghv = new THREE.Vector3(0, -0.45, 0);
            liv = new THREE.Vector3(0.9, -0.45, 0);
            ghpx = ghv.project(camera);
            lipx = liv.project(camera);
            ghLogo.style.top = `${-((ghpx.y - 1) / 2) * window.innerHeight}px`;
            ghLogo.style.left = `${((ghpx.x + 1) / 2) * window.innerWidth}px`;
            ghLogo.style.scale = `${1 / ghv.distanceTo(camera.position)}`;
            liLogo.style.top = `${-((lipx.y - 1) / 2) * window.innerHeight}px`;
            liLogo.style.left = `${((lipx.x + 1) / 2) * window.innerWidth}px`;
            liLogo.style.scale = `${1 / liv.distanceTo(camera.position)}`;

            // find intersections
            raycaster.setFromCamera(pointer, camera);
            intersects = raycaster.intersectObjects([gh, li, cube]);

            if (intersects.length > 0 && intersects[0].object.clickable) { /* one or more intersections */
                document.body.style.cursor = 'pointer';
                intersects[0].object.userData.image.style.display = 'inline-block';
                intersects[0].object.userData.image.classList.add('shown');

                if (INTERSECTED != intersects[0].object) { /* new one */
                    if (INTERSECTED) { /* reset old one */
                        INTERSECTED.userData.image.classList.remove('shown');
                        INTERSECTED.userData.image.style.display = 'none';
                    }
                    INTERSECTED = intersects[0].object;
                }
            } else { /* no intersection */
                document.body.style.cursor = 'default';
                if (INTERSECTED) { /* reset old one */
                    INTERSECTED.userData.image.classList.remove('shown');
                }
                INTERSECTED = null;
            }

            // message
            if (camera.position.length() > 4) {
                [msgBox, msg].forEach(i => i.classList.add('shown'));
            } else {
                [msgBox, msg].forEach(i => i.classList.remove('shown'));
            }

            renderer.render(scene, camera);
        }

        function onPointerMove(event) { /* px to ndc */
            pointer.x = (event.clientX / window.innerWidth) * 2 - 1;
            pointer.y = - (event.clientY / window.innerHeight) * 2 + 1;
        }

        function onLinkClick(e) {
            if (intersects.length > 0 && intersects[0].object.clickable) {
                window.open(intersects[0].object.userData.URL);
                intersects[0].object.clkt = true;
                if ([li, gh].every(o => o.clkt)) ee.visible = true;
            }
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }
        window.addEventListener('resize', onWindowResize);
        document.addEventListener('mousemove', onPointerMove);
        document.addEventListener('click', onLinkClick);

        // Render loop ====================================================
        animate();
    </script>
</body>

</html>